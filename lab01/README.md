# Raed 
Задание:
Сложность: Medium

Напишите верхнеуровневый модуль, который будет использовать логику из модулей-заданий. Перед этим нужно будет придумать способ инкапсулировать логику для корректного импортирования.
Описание проделанной работы

Что я сделал

Мне нужно было создать программу, которая решает 11 разных задач. Вместо того чтобы писать всё в одном файле, я разделил логику на модули, чтобы код был понятным и удобным для поддержки.

Как я организовал код

1. Создал отдельные модули для каждой задачи

В файле modules.py я создал 11 классов, каждый из которых отвечает за свою задачу:

GeometryCalculator - считает площадь круга и проверяет, лежит ли точка внутри круга
MathPuzzle - решает математическую головоломку (как из 1 2 3 4 5 получить 25)
MovieProcessor - вырезает названия фильмов из строки
FamilyAnalyzer - считает рост отца и общий рост семьи
ZooManager - управляет зоопарком: добавляет медведя, птиц, убирает слона
MusicCalculatorList и MusicCalculatorDict - считают общее время песен
MessageDecryptor - расшифровывает секретное сообщение
FlowerAnalyzer - анализирует, какие цветы растут в саду и на лугу
ShopAnalyzer - преобразует данные о ценах в магазинах
StoreCalculator - считает стоимость товаров на складе
DistanceCalculator - вычисляет расстояния между городами
2. Инкапсулировал логику

Каждый класс содержит внутри себя всю необходимую логику. Например, в GeometryCalculator я спрятал формулу расчета площади и проверки точки в круге. Если нужно будет что-то изменить, я поменяю только один класс, и остальная программа не сломается.

3. Создал главный модуль

В файле main.py я написал код, который использует все созданные модули. Этот файл не содержит сложной логики расчетов - он только вызывает методы из модулей и выводит результаты.

Почему я сделал именно так

Читаемость кода

Когда логика разделена на модули, легче понять, что делает каждая часть программы. Можно открыть любой класс и сразу увидеть, за что он отвечает.

Удобство изменений

Если нужно исправить ошибку в расчете расстояний, я меняю только класс DistanceCalculator. Остальной код остается нетронутым.

Переиспользование

Теперь я могу использовать эти модули в других проектах. Например, класс GeometryCalculator пригодится для любых геометрических расчетов.

Тестирование

Каждый модуль можно проверить отдельно. Я тестировал каждый класс по отдельности, прежде чем собирать их в главной программе.

Что получилось в итоге

Я создал программу, которая:

Решает все 11 поставленных задач
Имеет четкую структуру: логика в модулях, управление в главном файле
Легко расширяется - можно добавить новые задачи, создав новые классы
Проста в понимании - каждый модуль делает одну конкретную вещь
Чему я научился

Инкапсуляции - как прятать сложную логику внутри классов
Модульности - как разделять программу на независимые части
Импорту модулей - как правильно использовать код из других файлов
Организации кода - как делать программу понятной и удобной для чтения
Как запустить программу

Убедитесь, что в папке есть файлы modules.py и main.py
Запустите в терминале:

bash
python3 main.py
Программа выведет результаты всех 11 задач



# Шпаргалка Git для быстрого копирования

## Базовая настройка
`git config --global user.name "Твое Имя"`
`git config --global user.email "твоя@почта.com"`

## Начало работы
`git init` - создать репозиторий
`git clone ссылка` - скопировать чужой репозиторий
`git status` - посмотреть что изменилось

## Сохранение изменений
`git add .` - добавить все файлы
`git add файл.py` - добавить один файл
`git commit -m "сообщение"` - сохранить изменения
`git log` - посмотреть историю

## Ветки
`git branch` - показать ветки
`git branch имя` - создать ветку
`git checkout имя` - переключиться на ветку
`git checkout -b имя` - создать и переключиться
`git merge ветка` - объединить ветки

## Работа с GitHub
`git remote add origin ссылка` - подключить GitHub
`git push origin main` - отправить на GitHub
`git pull origin main` - скачать с GitHub
`git fetch` - проверить изменения

## Отмена действий
`git checkout -- файл.py` - отменить изменения в файле
`git reset --soft HEAD~1` - отменить последний коммит
`git stash` - временно спрятать изменения
`git stash pop` - вернуть спрятанное

## Полезные команды
`git diff` - посмотреть изменения
`git rm файл` - удалить файл
`git mv старый новый` - переименовать
`git tag v1.0` - создать версию
`git push --tags` - отправить теги

## Короткие команды
`git add .` → `git commit -m "описание"` → `git push origin main`
Это три главные команды для работы каждый день.